#!/usr/bin/env ruby

require 'literate'
require 'pathname'
require 'fileutils'

# Literate extracts code from Leanpub Markdown files.
#
# Usage
#
#   literate [markdown_file] [template_directory]
#
# Examples
#
#   literate chapters/2-components.md code/public

def verify_and_resolve_paths!(paths)
  paths.each do |name, path|
    if path.nil? || path.empty?
      puts "Error: Expected argument `#{name.to_s}`"
      abort(USAGE_TEXT)
    end

    unless Pathname.new(path).absolute?
      path = File.join(Dir.pwd, path)
    end
  end

  return paths.values
end

USAGE_TEXT = %{
Usage:
\tExtract code
\t\tliterate [markdown_file] [template_directory]
\tGenerate diff
\t\tliterate -d [markdown_file] [target_diff_directory]
}

if ARGV.empty?
  abort(USAGE_TEXT)
end

if ARGV[0] == '--gen-rc'
  puts 'Generating .literaterc...'
  target = File.join(Dir.pwd, '.literaterc')
  if File.exists?(target)
    puts "\tAbort! .literaterc already exists."
    puts "\t#{target}"
  else
    source = File.expand_path(File.join(__FILE__, '../../','literaterc.example'))
    FileUtils.cp(source, target)
    puts 'Done.'
  end
  abort
end

if ARGV[0] == '-d'
  markdown_file = ARGV[1]
  target_diff_directory = ARGV[2]

  markdown_file, target_diff_directory = verify_and_resolve_paths!(
    markdown_file: markdown_file,
    target_diff_directory: target_diff_directory
  )

  Literate::extract_and_diff(markdown_file, target_diff_directory)
else
  markdown_file = ARGV[0]
  template_directory = ARGV[1]

  markdown_file, template_directory = verify_and_resolve_paths!(
    markdown_file: markdown_file,
    template_directory: template_directory
  )

  Literate::extract_and_render(markdown_file, template_directory)
end
